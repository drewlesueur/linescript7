# LineScript7 test suite
failures = 0

ASSERT_EQ actual expected label
    IF actual IS expected
        # ok
    ELSE
        GLOBAL failures += 1
        PRINT STRING FAIL: 
        PRINT label
        PRINT STRING expected=
        PRINT expected
        PRINT STRING actual=
        PRINT actual
    END
END

ASSERT_TRUE cond label
    IF cond
        # ok
    ELSE
        failures = failures + 1
        PRINT STRING FAIL: 
        PRINT label
    END
END

# Arithmetic and precedence
calc1 = 1 + 2 * 3
calc2 = (1 + 2) * 3
ASSERT_EQ calc1 7 "calc1"
ASSERT_EQ calc2 9 "calc2"
op1 = 10
op1 += 5
ASSERT_EQ op1 15 "plus-equals"
op2 = 20
op2 -= 3
ASSERT_EQ op2 17 "minus-equals"
op3 = 6
op3 *= 4
ASSERT_EQ op3 24 "times-equals"
op4 = 20
op4 /= 5
ASSERT_EQ op4 4 "divide-equals"
obj = { count: 1 }
obj.count += 2
ASSERT_EQ obj.count 3 "plus-equals-member"
foo.bar += 1
ASSERT_EQ foo.bar 1 "plus-equals-member-create"

# Strings
name = "Ada"
first = SUBSTR name 1 2
ASSERT_EQ first "Ad" "substr-basic"
sliceStr = SLICE "abc" 2 10
ASSERT_EQ sliceStr "bc" "slice-out-of-range-string"
sliceStr2 = SLICE "abc" 10 2
ASSERT_EQ sliceStr2 "" "slice-empty-string"
sliceStr3 = SLICE "abc" -1 -1
ASSERT_EQ sliceStr3 "c" "slice-negative-string"
sliceStr4 = SLICE "abc" 1 -1
ASSERT_EQ sliceStr4 "abc" "slice-negative-full"
trimmed = TRIM "  padded  "
ASSERT_EQ trimmed "padded" "trim"
starts = STARTS_WITH name "Ad"
ends = ENDS_WITH name "da"
ASSERT_TRUE starts "starts-with"
ASSERT_TRUE ends "ends-with"

# Arrays and indexing (1-based)
numbers = [1 2 3]
ASSERT_EQ numbers[1] 1 "array-index-1"
numbers[3] = 99
ASSERT_EQ numbers[3] 99 "array-index-assign"
missingIndex = numbers[10]
ASSERT_EQ missingIndex NULL "array-missing-index-null"

sliceArr = SLICE numbers 2 10
ASSERT_EQ (JOIN sliceArr ",") "2,99" "slice-out-of-range-array"
sliceArr2 = SLICE numbers 10 2
ASSERT_EQ (JOIN sliceArr2 ",") "" "slice-empty-array"
sliceArr3 = SLICE numbers -1 -1
ASSERT_EQ (JOIN sliceArr3 ",") "99" "slice-negative-array"
sliceArr4 = SLICE numbers 1 -1
ASSERT_EQ (JOIN sliceArr4 ",") "1,2,99" "slice-negative-full-array"

# Objects and missing keys
user = { name: name age: 30 }
user.city = "Phoenix"
ASSERT_EQ user.city "Phoenix" "object-dot"
missingKey = user.zip
ASSERT_EQ missingKey NULL "object-missing-key-null"

# LEN
ASSERT_EQ (LEN numbers) 3 "len-array"
ASSERT_EQ (LEN name) 3 "len-string"
ASSERT_EQ (LEN user) 3 "len-object"

# Boolean logic and comparisons
active = TRUE
age = 30
canVote = FALSE
IF active AND age >= 18
    canVote = TRUE
END
ASSERT_TRUE canVote "bool-and-compare"

grade = "B"
honors = FALSE
IF grade IS "A" OR grade IS "B"
    honors = TRUE
END
ASSERT_TRUE honors "bool-or-is"

# IF / ELSE
score = 8
IF score > 10
    letter = "A"
ELSE IF score > 7
    letter = "B"
ELSE
    letter = "C"
END
ASSERT_EQ letter "B" "if-else"

# NULL checks
missing = NULL
IF missing IS NULL
    missing = "fallback"
END
ASSERT_EQ missing "fallback" "null-guard"

# Functions
ADD a b
    RETURN a + b
END
sum = ADD 2 3
ASSERT_EQ sum 5 "func-return"

DOUBLE n
    n * 2
END
twice = DOUBLE 7
ASSERT_EQ twice 14 "func-implicit-return"

# Functions cannot update caller scope
outerVal = 1
BUMP
    outerVal = outerVal + 1
END
BUMP
ASSERT_EQ outerVal 1 "func-no-update-outer"

# Nested call cannot update caller scope
outerLocal = 5
INNER_BUMP
    outerLocal = outerLocal + 3
END
CALLER
    outerLocal = 10
    INNER_BUMP
END
CALLER
ASSERT_EQ outerLocal 5 "func-no-update-caller-scope"

# Functions can update globals only via GLOBAL
GLOBAL gVal = 1
INC_GLOBAL
    GLOBAL gVal = gVal + 4
END
INC_GLOBAL
ASSERT_EQ gVal 5 "func-global-update"

# Functions can read from caller scope (dynamic read)
READ_OUTER
    RETURN outerRead
END
SET_AND_READ
    outerRead = "hi"
    RETURN READ_OUTER
END
readVal = SET_AND_READ
ASSERT_EQ readVal NULL "func-dynamic-read"

# Function hoisting (call before definition)
hoistResult = HOISTED 2 3
ASSERT_EQ hoistResult 6 "func-hoist"
HOISTED a b
    RETURN a + b + 1
END

# Functions can read from global scope
GLOBAL gRead = "global"
READ_GLOBAL
    RETURN gRead
END
gReadVal = READ_GLOBAL
ASSERT_EQ gReadVal "global" "func-global-read"

# FOR and FOR EACH
total = 0
FOR i FROM 1 TO 3
    total = total + i
END
ASSERT_EQ total 6 "for-loop"

FOR EACH idx val IN numbers
    numbers[idx] = val + 1
END
ASSERT_EQ (JOIN numbers ",") "2,3,100" "for-each-index"

# FOR EACH variations (array/object, key+val and val-only)
sumArrayVals = 0
FOR EACH idx val IN numbers
    sumArrayVals = sumArrayVals + val
END
ASSERT_EQ sumArrayVals 105 "for-each-array-kv"

sumArrayVals2 = 0
FOR EACH val IN numbers
    sumArrayVals2 = sumArrayVals2 + val
END
ASSERT_EQ sumArrayVals2 105 "for-each-array-v"

objLoop = { a: 1 b: 2 c: 3 }
objSum = 0
FOR EACH key val IN objLoop
    objSum = objSum + val
END
ASSERT_EQ objSum 6 "for-each-obj-kv"

objSum2 = 0
keysArr = []
FOR EACH key IN objLoop
    PUSH keysArr key
END
ASSERT_EQ (JOIN keysArr ",") "a,b,c" "for-each-obj-k"

# Function def without END (indentation-based)
NO_END x
    x + 1
ASSERT_EQ (NO_END 4) 5 "func-no-end"


# Short-circuit AND/OR
GLOBAL sc = 0
SC_HIT
    GLOBAL sc += 1
    RETURN TRUE
END
FALSE AND SC_HIT
ASSERT_EQ sc 0 "and-short-circuit"
TRUE OR SC_HIT
ASSERT_EQ sc 0 "or-short-circuit"
TRUE AND SC_HIT
ASSERT_EQ sc 1 "and-eval-right"
FALSE OR SC_HIT
ASSERT_EQ sc 2 "or-eval-right"

# WHILE + CONTINUE + BREAK
i = 1
sumWhile = 0
WHILE i <= 5
    IF i IS 2
        i = i + 1
        CONTINUE
    END
    IF i IS 4
        BREAK
    END
    sumWhile = sumWhile + i
    i = i + 1
END
ASSERT_EQ sumWhile 4 "while-continue-break"

# Labeled BREAK / CONTINUE
sumLabel = 0
OUTER: FOR i FROM 1 TO 3
    INNER: FOR j FROM 1 TO 3
        IF i IS 2 AND j IS 2
            BREAK OUTER
        END
        sumLabel = sumLabel + 1
    END
END
ASSERT_EQ sumLabel 4 "labeled-break"

sumLabel2 = 0
OUT: FOR i FROM 1 TO 3
    FOR j FROM 1 TO 3
        IF j IS 2
            CONTINUE OUT
        END
        sumLabel2 = sumLabel2 + 1
    END
END
ASSERT_EQ sumLabel2 3 "labeled-continue"

# Labeled IF + BREAK
hit = 0
OUTIF: IF TRUE
    hit = hit + 1
    BREAK OUTIF
    hit = hit + 10
END
ASSERT_EQ hit 1 "labeled-if-break"

# GOTO
count = 0
START:
count = count + 1
IF count < 3
    GOTO START
END
ASSERT_EQ count 3 "goto-basic"

# SPLIT / JOIN
words = SPLIT "one,two,three" ","
ASSERT_EQ (JOIN words "-") "one-two-three" "split-join"

# Stack application (pipeline)
PRINT STRING stack-test
"Drew"
SLICE 1 2
UPPER
result = IT
ASSERT_EQ result "DR" "stack-pipeline"

# IT pops from stack
"hello"
popped = IT
ASSERT_EQ popped "hello" "it-pop"

# EXEC / EXEC2 / EXEC_COMBINED
execOut = EXEC "printf hello"
ASSERT_EQ execOut "hello" "exec-stdout"

execRes = EXEC2 "sh -c 'printf out; printf err 1>&2; exit 3'"
ASSERT_EQ execRes.code 3 "exec2-code"
ASSERT_EQ execRes.stdout "out" "exec2-stdout"
ASSERT_EQ execRes.stderr "err" "exec2-stderr"

combined = EXEC_COMBINED "sh -c 'printf out; printf err 1>&2'"
ASSERT_EQ combined "outerr" "exec-combined"

"howdy"; SLICE 2 4; UPPER; ASSERT_EQ IT "OWD" "semiconolns"

count = LEN "yo" + LEN "woa"
ASSERT_EQ count 5 "precedence-test"

TIMES2 x
    x * 2
END
 
"Hello" "World" 
second = IT
first = IT
ASSERT_EQ first "Hello" "stack-check1"
ASSERT_EQ second "World" "stack-check2"

ASSERT_EQ TIMES2 3 6 "optional-return"

IF TRUE
    "yay"
ELSE
    "nay"
END
ASSERT_EQ IT "yay" "stack-in-if"

numbers = [1 2 3]
numbers[1] = 100
ASSERT_EQ numbers[1] 100 "setting-index"
index = 2
numbers[index + 1] = 300
ASSERT_EQ numbers[3] 300 "setting-index-dynamic"

foo.bar.baz = "hi"
ASSERT_EQ foo.bar.baz "hi" "assign-nested"

yo[1] = "yo"
yo[2] = "woa"
ASSERT_EQ yo[2] "woa" "assign-nested-array"

someObj["bricks"] = "red"
ASSERT_EQ someObj.bricks "red" "assign-nested-3"

idx = 10
key = "smthng"


"Drew"
"Hello " IT
ASSERT_EQ IT "Hello Drew" "IT-on-same-line"

TRIM_ME
    TRIM
END

" ok "
trimmed = TRIM_ME
ASSERT_EQ trimmed "ok" "stack-across-func"

GREET
    "Hello, " IT; CONCAT
END
GREET1 name
    "Hello, " name; CONCAT
END
GREET1_ALT name
    "Hello, " name
    CONCAT
END
GREET1_ALT2 name
    "Hello, "
    CONCAT name
END
GREET1_ALT3 name
    "Hello, "; CONCAT name
END
greeting = GREET "Drew"
ASSERT_EQ greeting "Hello, Drew" "stack-across-function"

v = PLUS LEN "yo" LEN "woa"
ASSERT_EQ v 5 "arity-test"

# fails because no specific arity
# ASSERT_EQ GREET "Mr." "Hello, Mr." "stack-across-function"
ASSERT_EQ (GREET "Mr.") "Hello, Mr." "stack-across-function"
ASSERT_EQ GREET1 "Mr." "Hello, Mr." "stack-across-function"
ASSERT_EQ GREET1_ALT "Mr." "Hello, Mr." "stack-across-function"
ASSERT_EQ GREET1_ALT2 "Mr." "Hello, Mr." "stack-across-function"
ASSERT_EQ GREET1_ALT3 "Mr." "Hello, Mr." "stack-across-function"



FOR i FROM 1 TO 5
    PUSH myVals i
END
ASSERT_EQ myVals[5] 5 "FOR-test"

arr2 = [10 20 30]
SETAT arr2 2 99
ASSERT_EQ arr2[2] 99 "setat-array"
obj2 = { name: "Ada" }
SETAT obj2 "city" "NYC"
ASSERT_EQ obj2.city "NYC" "setat-object"

foo[idx][key].bar = 200
ASSERT_EQ foo[idx][key].bar 200 "nested"

IF failures IS 0
    PRINT STRING ALL TESTS PASSED
ELSE
    PRINT STRING FAILURES:
    PRINT failures
END
